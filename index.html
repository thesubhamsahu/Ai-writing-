<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Writing</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
          integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg=="
          crossorigin="anonymous" referrerpolicy="no-referrer"/>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Architects+Daughter&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #121212;
            color: #fff;
            display: flex;
            flex-direction: column;
            height: 100vh; /* Adjusted to fill full viewport height */
            transition: background-color 0.3s ease, color 0.3s ease;
            overflow: hidden; /* Prevent vertical scroll on body */
        }

        body.light_mode {
            background-color: #fff;
            color: #000;
        }

        header {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 1rem;
            background-color: #1e1e1e;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        body.light_mode header {
            background-color: #eee;
            color: #000;
        }

        .header-buttons {
             display: flex;
             align-items: center;
              flex: 1;
             gap: 10px;
         }

        .animation-container {
            /* flex: 1;  Removed flex: 1 */
            overflow-x: auto;
            overflow-y: hidden;
            display: flex;
            flex-direction: row;
            scroll-snap-type: x mandatory;
            scrollbar-width: none;
            -ms-overflow-style: none;
            transition: transform 0.3s ease-in-out;
            height: calc(90vh - 60px); /* Adjust height, subtract header and input area roughly */
        }

        .animation-container::-webkit-scrollbar {
            display: none;
        }

        .animation-page {
            scroll-snap-align: start;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            padding: 1rem;
            flex-shrink: 0; /* Prevent shrinking */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .animation-box {
            border: 1px solid #aaa;
            padding: 10px;
            font-size: 19px;
            overflow-y: auto;
            white-space: pre-wrap;
            position: relative;
            background-color: #121212;
            color: #000080;
            font-family: "Architects Daughter", serif;
            line-height: 29.41px; /* Reduced line-height to fit more lines */
            background-image: linear-gradient(to bottom, transparent 28.41px, #ddd 28.41px, #ddd 29.41px, transparent 29.41px); /* Adjusted background-image */
            background-size: 100% 29.41px; /* Adjusted background-size */
            background-attachment: local;
            user-select: none;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -ms-touch-action: manipulation;
            touch-action: manipulation;
            overflow: hidden;
            height: 100%;
            box-sizing: border-box;
            width: 100%;
        }

        body.light_mode .animation-box {
            background-color: #f9f9f9;
            color: #000080;
            border: 1px solid #ccc;
             background-image: linear-gradient(to bottom, transparent 28.41px, #ddd 28.41px, #ddd 29.41px, transparent 29.41px); /* Adjusted background-image */
             background-size: 100% 29.41px; /* Adjusted background-size */
        }

        .animation-box::before,
        .animation-box::after {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.2);
            opacity: 0;
            transition: opacity 0.15s ease-out;
            pointer-events: none;
        }

        .animation-box.touch-left::before {
            left: 0;
            width: 50%;
            opacity: 1;
        }

        .animation-box.touch-right::after {
            right: 0;
            width: 50%;
            opacity: 1;
        }

        .input-box {
            font-family: Arial, sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #1e1e1e;
            border-radius: 8px;
            padding: 0.5rem 1rem;
            width: calc(100%);
            box-sizing: border-box;
            min-height: 40px;
            transition: background-color 0.3s ease;
        }

        body.light_mode .input-box {
            background-color: #eee;
        }

        .input-box .editable-div {
            background-color: transparent;
            outline: none;
            color: inherit;
            width: 100%;
            box-sizing: border-box;
            word-wrap: break-word;
            white-space: pre-wrap;
            font-family: inherit;
            font-size: 1rem;
            height: 100%;
            overflow-y: auto;
        }

        .input-box .editable-div::placeholder {
            color: inherit;
            opacity: 0.5;
        }

        .typing-form {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            background-color: #1e1e1e;
            gap: 0.5rem;
            transition: background-color 0.3s ease;
            position: sticky;
            bottom: 0;
        }

        body.light_mode .typing-form {
            background-color: #eee;
        }

        .typing-input {
            flex: 1;
            padding: 0.5rem;
            border: none;
            border-radius: 4px;
            font-size: 1rem;
            color: inherit;
            background-color: inherit;
        }

        .send-button {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            font-size: 1rem;
            background-color: #333;
            color: #fff;
            cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        body.light_mode .send-button {
            background-color: #ccc;
            color: #000;
        }

        .send-button:hover {
            background-color: #555;
        }

        body.light_mode .send-button:hover {
            background-color: #aaa;
        }

        .blinking-cursor {
            display: inline-block;
            width: 2px;
            height: 1em;
            background-color: #fff;
            margin-left: 2px;
            animation: blink 1s steps(2, start) infinite, opacityBlink 1s linear infinite alternate;
            position: absolute;
        }

        body.light_mode .blinking-cursor {
            background-color: #000;
        }

        @keyframes blink {
            to {
                visibility: hidden;
            }
        }

        @keyframes opacityBlink {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        .dimmed-text {
            opacity: 0.52;
            transition: opacity 0.3s ease-in-out;
        }
    </style>
</head>
<body class="light_mode">
<header>
    <div class="header-buttons">
    </div>
</header>
<div class="animation-container">
</div>
<form class="typing-form">
    <input type="text" class="typing-input" placeholder="Type a message..."/>
    <button type="submit" class="send-button">Send</button>
</form>
<script>
    const typingForm = document.querySelector(".typing-form");
    const animationContainer = document.querySelector(".animation-container");

    const API_KEY = "AIzaSyCH_a36UpmdGBrXFscwR4OGRJkH4MNNmpg";
    const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${API_KEY}`;
    let isResponseGenerating = false;
    let INITIAL_PROMPT = `Write an essay on topic in 800 words in paragraphs`;

    const createAnimationBox = () => {
        const div = document.createElement("div");
        div.className = "animation-box";
        const cursorSpan = document.createElement("span");
        cursorSpan.className = "blinking-cursor";
        div.appendChild(cursorSpan);
        return div;
    };

    const createAnimationPage = () => {
        const div = document.createElement("div");
        div.className = "animation-page";
        return div;
    }

    let normalSpeed = 290;
    const minSpeed = 50;
    const maxSpeed = 500;
    let displayInterval;
    let currentDisplayBox = null;
    let touchStartX = 0;
    let currentPageIndex = 0;

    function dimPreviousSentence(displayBox) {
        let foundFullStop = false;
        let nodesToDim = [];
        for (let i = displayBox.childNodes.length - 2; i >= 0; i--) {
            const node = displayBox.childNodes[i];
            if (node.textContent === ".") {
                foundFullStop = true;
                break;
            }
            nodesToDim.unshift(node);
        }

        if (foundFullStop) {
            nodesToDim.forEach(node => {
                if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== "") {
                    const span = document.createElement('span');
                    span.textContent = node.textContent;
                    span.classList.add('dimmed-text');
                    displayBox.replaceChild(span, node);
                }
            });
        }
    }

    function animateMessageBox(displayBox, text) {
        currentDisplayBox = displayBox;
        let currentIndex = 0;
        let cursor = displayBox.querySelector(".blinking-cursor");
        const textArray = text.split("");

        function displayText() {
            if (currentIndex < textArray.length) {
                const nextChar = textArray[currentIndex];
                const tempNode = document.createTextNode(nextChar);
                displayBox.insertBefore(tempNode, cursor);

                if (displayBox.scrollHeight > displayBox.clientHeight) {
                    // Remove the last added character that caused overflow
                    displayBox.removeChild(tempNode);
                    // Create a new page and continue with the overflowing character
                    createNewPageAndContinue(textArray.slice(currentIndex).join(""));
                    return;
                }

                currentIndex++;

                const currentChar = nextChar;
                if (currentChar === ".") {
                    dimPreviousSentence(displayBox);
                }

                clearInterval(displayInterval);
                displayInterval = setInterval(displayText, normalSpeed);
            } else {
                clearInterval(displayInterval);
                if (cursor) {
                    cursor.remove();
                }
                currentDisplayBox = null;
            }
        }

        displayText(); // Start the animation immediately

        displayBox.addEventListener('touchstart', function(e) {
            const rect = displayBox.getBoundingClientRect();
            const touchX = e.touches[0].clientX - rect.left;

            if (touchX < rect.width / 2) {
                displayBox.classList.add('touch-left');
                displayBox.classList.remove('touch-right');
            } else {
                displayBox.classList.add('touch-right');
                displayBox.classList.remove('touch-left');
            }

            if (touchX < rect.width / 3) {
                normalSpeed = Math.min(maxSpeed, normalSpeed + 50);
            } else if (touchX > 2 * rect.width / 3) {
                normalSpeed = Math.max(minSpeed, normalSpeed - 50);
            }

            if (currentDisplayBox === displayBox && currentIndex < textArray.length) {
                clearInterval(displayInterval);
                displayInterval = setInterval(displayText, normalSpeed);
            }
        });

        const resetTouchEffect = () => {
            displayBox.classList.remove('touch-left', 'touch-right');
        };

        displayBox.addEventListener('touchend', resetTouchEffect);
        displayBox.addEventListener('touchcancel', resetTouchEffect);
    }

    const createNewPageAndContinue = (remainingText) => {
        const newPage = createAnimationPage();
        const newBox = createAnimationBox();
        newPage.appendChild(newBox);
        animationContainer.appendChild(newPage);
        // Immediately scroll to the new page
        animationContainer.scrollLeft = animationContainer.scrollWidth;
        animateMessageBox(newBox, remainingText);
    };

    const fetchResponse = async (inputText) => {
        isResponseGenerating = true;

        const animationPage = createAnimationPage();
        const animationBox = createAnimationBox();
        animationPage.appendChild(animationBox);
        animationContainer.appendChild(animationPage);
        // Immediately scroll to the new page
        animationContainer.scrollLeft = animationContainer.scrollWidth;

        try {
            const response = await fetch(API_URL, {
                method: "POST",
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify({
                    contents: [
                        {
                            role: "user",
                            parts: [{text: `${INITIAL_PROMPT} ${inputText}`}],
                        },
                    ],
                }),
            });
            const data = await response.json();
            if (!response.ok) throw new Error(data.error.message);

            let apiResponse = data.candidates[0].content.parts[0].text;
            animateMessageBox(animationBox, apiResponse);

        } catch (error) {
            animationBox.textContent = `Error: ${error.message}`;
             const cursor = animationBox.querySelector(".blinking-cursor");
            if (cursor) {
                cursor.remove();
            }
        } finally {
            isResponseGenerating = false;
        }
    };

    typingForm.addEventListener("submit", (e) => {
        e.preventDefault();
        if (isResponseGenerating) return;

        const inputText = typingForm.querySelector(".typing-input").value.trim();
        if (!inputText) return;

        typingForm.reset();
        fetchResponse(inputText);
    });

    // Swipe functionality
    animationContainer.addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
    });

    animationContainer.addEventListener('touchend', (e) => {
        const touchEndX = e.changedTouches[0].clientX;
        const swipeDistance = touchEndX - touchStartX;
        const pageWidth = animationContainer.offsetWidth;

        if (Math.abs(swipeDistance) > 50) { // Adjust threshold as needed
            if (swipeDistance < 0) {
                // Swipe left, go to next page
                currentPageIndex = Math.min(currentPageIndex + 1, animationContainer.children.length - 1);
            } else {
                // Swipe right, go to previous page
                currentPageIndex = Math.max(0, currentPageIndex - 1);
            }

            animationContainer.scrollLeft = currentPageIndex * pageWidth;
        }
    });
</script>
</body>
</html>
